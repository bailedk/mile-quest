# Hydration Guide for Mile Quest Frontend

## Overview

This guide explains hydration issues in Next.js and provides best practices for avoiding hydration mismatches in the Mile Quest application.

## What is Hydration?

Hydration is the process where React takes the static HTML generated by the server and makes it interactive by attaching event handlers and state. For this to work correctly, the HTML generated on the server must exactly match what React generates on the client during the first render.

## Common Causes of Hydration Errors

### 1. Browser-Only APIs
```typescript
// ❌ BAD - Will cause hydration error
const Component = () => {
  const width = window.innerWidth; // window is undefined on server
  return <div>Width: {width}</div>;
};

// ✅ GOOD - Use useEffect or hydration utilities
const Component = () => {
  const [width, setWidth] = useState(0);
  
  useEffect(() => {
    setWidth(window.innerWidth);
  }, []);
  
  return <div>Width: {width}</div>;
};
```

### 2. localStorage/sessionStorage
```typescript
// ❌ BAD - localStorage doesn't exist on server
const [user] = useState(() => {
  return JSON.parse(localStorage.getItem('user') || '{}');
});

// ✅ GOOD - Use hydration-safe localStorage hook
import { useLocalStorage } from '@/utils/hydration';
const [user, setUser] = useLocalStorage('user', {});
```

### 3. Date/Time/Random Values
```typescript
// ❌ BAD - Different values on server and client
const Component = () => {
  const id = Math.random();
  const time = new Date().toLocaleTimeString();
  return <div id={id}>{time}</div>;
};

// ✅ GOOD - Use stable values or delay generation
import { useStableId } from '@/utils/hydration';
const Component = () => {
  const id = useStableId('component');
  const [time, setTime] = useState('');
  
  useEffect(() => {
    setTime(new Date().toLocaleTimeString());
  }, []);
  
  return <div id={id}>{time}</div>;
};
```

### 4. Environment Variables
```typescript
// ❌ BAD - NODE_ENV might differ between builds
const Component = () => {
  if (process.env.NODE_ENV === 'development') {
    return <DevTools />;
  }
  return null;
};

// ✅ GOOD - Use hydration check
import { useIsDevelopment } from '@/utils/hydration';
const Component = () => {
  const isDev = useIsDevelopment();
  
  if (isDev) {
    return <DevTools />;
  }
  return null;
};
```

## Available Hydration Utilities

### 1. useHydrated Hook
```typescript
import { useHydrated } from '@/hooks/useHydrated';

const Component = () => {
  const hydrated = useHydrated();
  
  if (!hydrated) {
    return <LoadingSpinner />;
  }
  
  // Safe to use browser APIs here
  return <div>Client-side content</div>;
};
```

### 2. useSyncExternalStore for Browser APIs
```typescript
import { useSyncExternalStore } from 'react';

// Example: Online status hook
const isOnline = useSyncExternalStore(
  subscribe,     // Subscribe to changes
  getSnapshot,   // Get current value on client
  getServerSnapshot // Get value on server (SSR)
);
```

### 3. Hydration-Safe Hooks
```typescript
import {
  useMediaQuery,
  useWindowDimensions,
  useLocalStorage,
  useDeviceDetection,
  usePrefersReducedMotion,
  usePrefersColorScheme
} from '@/utils/hydration';

// All these hooks handle SSR/hydration correctly
const isMobile = useMediaQuery('(max-width: 768px)');
const { width, height } = useWindowDimensions();
const [theme, setTheme] = useLocalStorage('theme', 'light');
const { isMobile, isTablet } = useDeviceDetection();
const prefersReducedMotion = usePrefersReducedMotion();
const colorScheme = usePrefersColorScheme();
```

### 4. HydratedOnly Component
```typescript
import { HydratedOnly } from '@/utils/hydration';

const Page = () => {
  return (
    <div>
      <h1>Always visible</h1>
      <HydratedOnly fallback={<Skeleton />}>
        <ClientOnlyComponent />
      </HydratedOnly>
    </div>
  );
};
```

## Best Practices

### 1. Zustand Stores with Persistence
```typescript
// Always use skipHydration: true for persisted stores
export const useAuthStore = create<AuthStore>()(
  persist(
    (set, get) => ({
      // store implementation
    }),
    {
      name: 'auth-storage',
      skipHydration: true, // Prevents automatic hydration
    }
  )
);

// Manually rehydrate in Providers
useEffect(() => {
  useAuthStore.persist.rehydrate();
}, []);
```

### 2. Component Patterns
```typescript
// Pattern 1: Conditional rendering with hydration check
const Header = () => {
  const hydrated = useHydrated();
  const { isAuthenticated } = useAuthStore();
  
  const showAuthNav = hydrated && isAuthenticated;
  
  return (
    <nav>
      {showAuthNav ? <AuthenticatedNav /> : <PublicNav />}
    </nav>
  );
};

// Pattern 2: Dynamic imports for client-only components
const ClientOnlyChart = dynamic(
  () => import('@/components/Chart'),
  { ssr: false }
);

// Pattern 3: Stable fallbacks during SSR
const ResponsiveComponent = () => {
  const { width } = useWindowDimensions();
  
  // Provide sensible defaults that match SSR
  const columns = width > 0 ? Math.floor(width / 300) : 3;
  
  return <Grid columns={columns} />;
};
```

### 3. Style Injection
```typescript
// ❌ BAD - Injects styles during module load
const styles = `...`;
if (typeof document !== 'undefined') {
  const style = document.createElement('style');
  style.textContent = styles;
  document.head.appendChild(style);
}

// ✅ GOOD - Inject styles in useEffect
const Component = () => {
  useEffect(() => {
    const style = document.createElement('style');
    style.textContent = styles;
    document.head.appendChild(style);
    
    return () => {
      document.head.removeChild(style);
    };
  }, []);
  
  return <div>...</div>;
};
```

## Debugging Hydration Errors

### 1. Enable React's Detailed Error Messages
```javascript
// In development, React provides detailed hydration error messages
// Look for the specific mismatch in the console
```

### 2. Use the Test Page
```typescript
// Visit /test-hydration to see hydration state
// Shows what values differ between server and client
```

### 3. Common Error Patterns
- **"Text content did not match"** - Usually date/time or random values
- **"Hydration failed because initial UI does not match"** - Structure mismatch
- **"Expected server HTML to contain matching"** - Missing elements

### 4. Debugging Steps
1. Check console for specific error details
2. Look for browser API usage in initial render
3. Check for conditional rendering based on client state
4. Verify Zustand stores have skipHydration: true
5. Ensure dynamic imports use { ssr: false } when needed

## Migration Checklist

When adding new features or components:

- [ ] Use `useHydrated()` before accessing browser APIs
- [ ] Initialize state with SSR-safe values
- [ ] Use hydration utilities for media queries and dimensions
- [ ] Add `skipHydration: true` to persisted Zustand stores
- [ ] Inject styles and scripts in useEffect
- [ ] Use `useSyncExternalStore` for external state
- [ ] Test with JavaScript disabled to see SSR output
- [ ] Check browser console for hydration warnings

## Quick Reference

```typescript
// Import all hydration utilities
import {
  useHydrated,
  useMediaQuery,
  useWindowDimensions,
  useLocalStorage,
  useDeviceDetection,
  useStableId,
  useIsDevelopment,
  usePrefersReducedMotion,
  usePrefersColorScheme,
  HydratedOnly,
  isBrowser,
  isServer,
  safeWindow,
  safeDocument,
  safeNavigator,
  safeLocalStorage
} from '@/utils/hydration';
```

## Resources

- [Next.js Hydration Documentation](https://nextjs.org/docs/messages/react-hydration-error)
- [React useSyncExternalStore](https://react.dev/reference/react/useSyncExternalStore)
- [Zustand Persist Middleware](https://github.com/pmndrs/zustand#persist-middleware)